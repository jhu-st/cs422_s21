/**
 * 
 * Instructions:
 * 1) Write adequate JUnit tests for MathUtils class below based on given method specifications. 
 *    Try to think as many different test cases as you can (think about all special/corner/edge etc. cases).
 *    Store your test cases into "MathUtilsTest.java".
 *    
 * 2) When doing so, you should be able to find ambiguity, inconsistencies, mistakes, and/or lack of details in the specifications and/or the code.
 * 
 * 3) Fix the issues you have found in the previous part and save your work in a separate class (i.e., .java file) named 
 *    "MathUtilsFixed.java". You need to detail all the modifications you have made in the form of comments in the new file.
 *    
 * 4) Do mutation testing manually on the fixed implementation:
 *	  a) For each method, choose 4 different types of mutation operators. Generate at least two mutants
 *       for each chosen mutation operator.
 *       
 *    b) Each mutant you write should be saved into a separate java file, named "MUO_M_X.java",
 *    	 where MUO is the name of the mutation operator used, M is the name of method mutated, 
 *       and X is the mutant number (1 or 2).
 *       i) inside each mutant, make sure you make it clear where you have made a change to produce the mutant in the form of a comment. 
 *       Also, you need to report whether the mutant is killed (strongly) or not by any of the test cases that you wrote in part 1.
 *       ii) Explain how the mutant gets killed by the test case(s) that kill(s) it
 *       iii) If any mutant does not get killed by any of the test cases, explain/justify why that is the case. If it is possible to 
 *       add a test case to kill the mutant, go ahead and add it to your JUnit tests. Make sure you leave a comment: "added to kill mutant X after doing 
 *       mutation analysis", where X is the name of the mutant java file (i.e., "MUO_M_X.java").
 *       
 *   d) Are there any equivalent mutants that you wrote? Report them by leaving a comment on the top of the equivalent mutant java file (i.e., "MUO_M_X.java"). 
 *    	
 * 5) Run PIT on your fixed implementations and your JUnit tests. What is line coverage and what is the mutation score of your test suite
 *    as reported by PIT? Reflect on those numbers and see if you can improve them. If possible, add more test cases to your JUnit tests to 
 *    increase the mutation score further. If you add any JUnit tests, make sure you leave a comment: "added after 
 *    PIT analysis". Aim for 100% mutation score (killing all the mutants). If it is possible to achieve that, write down why in the form comments on the top of the 
 *    JUnit file. Finally, for this part, you need to submit the complete report generated by PIT. When PIT finishes, in the console, you 
 *    should see a message toward the bottom saying "Sending results: PitResults [htmlResultFile=PATH\index.html, projects=[X]] where PATH 
 *    is where the report is saved to on your hard disk. Make sure you submit that folder completely, not just index.html, otherwise you 
 *    will not get any points for this part.    
 *     
 * 6) Submission check list for this part: 1) fixed implementation (MathUtilFixed.java), b) complete JUnit test cases (MathUntilsTest.java),
 *    , c) all mutant files (i.e., all the files saved as "MU_M_X.java"), and d) complete PIT report
 * 
 * */


public class MathUtils {
	
	/**
     * This returns the slope of the given points.
     * @param x1 the first x to use
     * @param x2 the end x to use
     * @param y1 the begin y to use
     * @param y2 the end y to use
     * @return the slope of the given points
     */
    public static double slope(double x1, double x2, double y1, double y2) {
        return (y2-y1)/(x1-x2);
    }
    
    
    /**
     * This returns the squared root mean squared error of two data sets
     * @param real the real values
     * @param predicted the predicted values
     * @return the root means squared error for two data sets
     */
    public static double rootMeansSquaredError(double[] real, double[] predicted) {
        double ret= 0.0;
        for(int i=0; i < real.length; i++) {
            ret = Math.pow((real[i]-predicted[i]), 2);
        }
        return Math.sqrt(ret / real.length);
    }
    
    
    /**
     * This returns the sum of squares for a given vector.
     *
     * @param vector the vector to obtain the sum of squares for
     * @return the sum of squares for vector
     */
    public static double sumOfSquares(double[] vector) {
        double ret=0;
        for(double d : vector) ret = Math.pow(d, 2);
        return ret;
    }
    
    /**
     * This returns the given column over n arrays
     * @param column the column to getFromOrigin values for
     * @param nums the arrays to extract values from
     * @return a double array containing all of the numbers in that column
     * for all of the arrays.
     * @throws IllegalArgumentException if the index is invalid
     */
    protected static double[] getColumn(int column, double[] ... nums) {

        double[] ret = new double[nums.length];

        for(int i=0; i < nums.length; i++) {
            double[] curr = nums[i];
            ret[i] = curr[column];
        }
        return ret;
    }
    
    
    /**
     * Normalizes the doubles in the array using a given value.
     *
     * @param doubles the array of double
     * @param sum the value by which the doubles are to be normalized
     * @exception IllegalArgumentException if sum is zero or NaN
     */
    public static void normalize(double[] doubles, double sum) {

        for (int i = 0; i < doubles.length; i++) {
            doubles[i] /= sum;
        }
    }
    
    /**
     * This returns the entropy for a given vector of probabilities.
     * entropy = - \sum_i p_i * log(p_i)
     * @param probabilities a list of probabilities, probabilities should be valid values in the range (0, 1)
     * @return the entropy of the given probabilities.
     */
    public static double calEntropy(double[] probabilities) {
        double total = 0.0;
        for (double d : probabilities) {

            total += (Math.log(d) * d);
        }
        return total;
    }
    
}
